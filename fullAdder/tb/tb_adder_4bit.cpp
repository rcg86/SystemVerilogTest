//=============================================================================
// Testbench: tb_adder_4bit.cpp
// Description: Verilator C++ testbench for 4-bit ripple carry adder
//              Performs exhaustive testing of all 512 input combinations
// Author: SystemVerilog Lab Series
// Date: 2026-01-10
//=============================================================================

#include <iostream>
#include <iomanip>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vadder_4bit.h"  // Generated by Verilator from adder_4bit.sv

using namespace std;

// Simulation time counter (global for Verilator)
vluint64_t sim_time = 0;

int main(int argc, char** argv) {
    
    // Initialize Verilator
    Verilated::commandArgs(argc, argv);
    
    // Create instance of our module
    Vadder_4bit* dut = new Vadder_4bit;
    
    // Enable waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    dut->trace(tfp, 99);  // Trace 99 levels of hierarchy
    tfp->open("sim/adder_4bit.vcd");  // Output VCD file
    
    // Test counters
    int num_tests = 0;
    int num_passed = 0;
    int num_failed = 0;
    
    cout << "========================================" << endl;
    cout << "4-bit Ripple Carry Adder Testbench" << endl;
    cout << "========================================" << endl;
    cout << endl;
    
    // Exhaustive testing: try all combinations of a, b, cin
    // a: 0-15 (4 bits), b: 0-15 (4 bits), cin: 0-1 (1 bit)
    // Total: 16 * 16 * 2 = 512 test cases
    
    for (int a_val = 0; a_val < 16; a_val++) {
        for (int b_val = 0; b_val < 16; b_val++) {
            for (int cin_val = 0; cin_val < 2; cin_val++) {
                
                // Apply inputs to DUT
                dut->a = a_val;
                dut->b = b_val;
                dut->cin = cin_val;
                
                // Evaluate the design (run combinational logic)
                dut->eval();
                
                // Calculate expected result
                int expected = a_val + b_val + cin_val;
                int expected_sum = expected & 0xF;  // Lower 4 bits
                int expected_cout = (expected >> 4) & 0x1;  // Bit 4
                
                // Get actual result from DUT
                int actual_sum = dut->sum;
                int actual_cout = dut->cout;
                
                // Compare expected vs actual
                bool pass = (actual_sum == expected_sum) && 
                           (actual_cout == expected_cout);
                
                num_tests++;
                if (pass) {
                    num_passed++;
                } else {
                    num_failed++;
                    // Print failures for debugging
                    cout << "FAIL: a=" << a_val 
                         << " b=" << b_val 
                         << " cin=" << cin_val
                         << " | Expected: sum=" << expected_sum 
                         << " cout=" << expected_cout
                         << " | Got: sum=" << actual_sum 
                         << " cout=" << actual_cout << endl;
                }
                
                // Dump waveform for this timestep
                tfp->dump(sim_time);
                sim_time += 10;  // Advance time by 10 time units
            }
        }
    }
    
    cout << endl;
    cout << "========================================" << endl;
    cout << "Test Results:" << endl;
    cout << "  Total Tests: " << num_tests << endl;
    cout << "  Passed:      " << num_passed << endl;
    cout << "  Failed:      " << num_failed << endl;
    
    if (num_failed == 0) {
        cout << "  Status: ALL TESTS PASSED ✓" << endl;
    } else {
        cout << "  Status: SOME TESTS FAILED ✗" << endl;
    }
    cout << "========================================" << endl;
    
    // Cleanup
    tfp->close();
    delete dut;
    delete tfp;
    
    // Return 0 if all tests passed, 1 otherwise
    return (num_failed == 0) ? 0 : 1;
}
